import random
from datetime import UTC, timedelta

from aiogram import F, Router
from aiogram.exceptions import TelegramAPIError
from aiogram.filters import StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.types import (
    CallbackQuery,
    InlineKeyboardButton,
    Message,
)
from aiogram.utils.keyboard import InlineKeyboardBuilder
from bson import ObjectId

from base.actions import game, sleep, street, work
from base.items import ITEMS
from base.player import (
    add_user_usage_item,
    check_user_stats,
    coin_top,
    dog_level_top,
    generate_quest,
    get_available_items_for_use,
    get_or_add_user_item,
    karma_top,
    level_top,
    use_item,
)
from database.funcs import database
from database.models import DogModel
from helpers.datetime_utils import utcnow
from helpers.enums import ItemRarity, ItemType
from helpers.exceptions import ItemIsCoin, NoResult
from helpers.markups import InlineMarkup
from helpers.messages import Messages
from helpers.utils import (
    achievement_progress,
    batched,
    check_user_subscription,
    get_achievement,
    get_item,
    get_item_count_for_rarity,
    get_item_emoji,
    get_middle_item_price,
    get_time_difference_string,
    get_user_tag,
    increment_achievement_progress,
    quick_markup,
    safe,
)

router = Router()


@router.callback_query(F.data.startswith("dog"))
async def dog_callback(call: CallbackQuery):
    data = call.data.split(" ")
    user = await database.users.async_get(id=call.from_user.id)

    try:
        dog = await database.dogs.async_get(owner=user._id)
    except NoResult:
        dog = None

    if not isinstance(call.message, Message):
        return

    if data[-1] != str(user.id):
        return
    if data[1] == "leave":
        await call.message.delete()
        await call.message.answer_sticker(
            "CAACAgIAAxkBAAEpvztl21ybsmS9RVqaYhV8ZtA353n4HgACJwEAAjDUnRGOYUDc7Hyw5TQE",
        )

        await call.message.answer("–ü—Ä–æ–≥–Ω–∞–ª –±–µ–¥–Ω—É—é —Å–æ–±–∞—á–∫—É(")
        return
    if data[1] == "friend":
        date = call.message.date.astimezone(UTC)
        current_time = utcnow()
        time_difference = current_time - date

        if time_difference >= timedelta(minutes=1):
            await call.message.delete()
            await call.answer("–ü–æ–∫–∞ —Ç—ã –¥—É–º–∞–ª –ø—Å–∏–Ω–∞ —Å–±–µ–∂–∞–ª–∞", show_alert=True)
            return

        item = get_or_add_user_item(user, "–∫–æ—Å—Ç—å")

        if item.quantity <= int(data[2]):
            await call.answer(
                f"–¢–µ–±–µ –Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç ü¶¥, –Ω—É–∂–Ω–æ {data[2]} –∞ —É —Ç–µ–±—è {item.quantity}", show_alert=True
            )
            return

        dog = DogModel(owner=user._id)
        dog.name = f"–°–æ–±–∞—á–∫–∞-{user.id}"
        await database.dogs.async_add(**dog.to_dict())

        await call.message.delete()
        await call.message.answer_sticker(
            "CAACAgIAAxkBAAEpvz9l211Kyfi280mwFR6XMKUhzMXbiwACGAEAAjDUnREiQ2-IziTqFTQE"  # cspell:disable-line # pylint: disable=line-too-long
        )

        await call.message.answer(
            "–ó–∞–≤–µ–ª —Å–æ–±–∞—á–∫—É üê∂\n\n–ù–∞–ø–∏—à–∏ /rename_dog [–∏–º—è] —á—Ç–æ–±—ã –¥–∞—Ç—å –∏–º—è –ø—ë—Å–∏–∫—É",
        )
        return
    if data[1] == "feed" and dog:
        if dog.hunger == 0:
            await call.answer(f"{dog.name} –Ω–µ –≥–æ–ª–æ–¥–µ–Ω", show_alert=True)
            return
        item = get_or_add_user_item(user, "–º—è—Å–æ")

        quantity = dog.level * 2

        if item.quantity < quantity:
            await call.answer(
                f"–¢–µ–±–µ –Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç –º—è—Å–∞, –Ω—É–∂–Ω–æ {quantity} –∞ —É —Ç–µ–±—è {item.quantity}",
                show_alert=True,
            )
            return
        item.quantity -= quantity
        count = random.randint(1, 10)
        dog.hunger -= count
        dog.xp += random.uniform(0.1, 0.3)
        await call.answer(
            f"{dog.name} –ø–æ–µ–ª –º—è—Å–∞ –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏–ª {count} –µ–¥–∏–Ω–∏—Ü –≥–æ–ª–æ–¥–∞",
            show_alert=True,
        )
        await database.dogs.async_update(**dog.to_dict())
        await database.items.async_update(**item.to_dict())

        await check_user_stats(user, call.message.chat.id)

        mess = (
            f"<b>{dog.name}</b>\n\n"
            f"–ó–¥–æ—Ä–æ–≤—å–µ: {dog.health}\n"
            f"–£—Å—Ç–∞–ª–æ—Å—Ç—å: {dog.fatigue}\n"
            f"–ì–æ–ª–æ–¥: {dog.hunger}\n"
            f"–£—Ä–æ–≤–µ–Ω—å: {dog.level}\n"
            f"–û–ø—ã—Ç {int(dog.xp)}/{int(dog.max_xp)}\n"
        )

        markup = quick_markup(
            {
                "–ö–æ—Ä–º–∏—Ç—å": {"callback_data": f"dog feed {user.id}"},
                # "–£–ª–æ–∂–∏—Ç—å —Å–ø–∞—Ç—å": {"callback_data": f"dog sleep {user.id}"}
            }
        )

        await call.message.edit_text(mess, reply_markup=markup)
    if data[1] == "sleep" and dog:
        current_time = utcnow()
        time_difference = current_time - dog.sleep_time
        if time_difference <= timedelta(minutes=1):
            time_difference = get_time_difference_string(time_difference - timedelta(minutes=1))
            await call.answer(
                f"{dog.name} —Å–ø–∏—Ç, –∂–¥–∏ {time_difference}",
                show_alert=True,
            )
            return

        dog.sleep_time = utcnow()

        time_difference = get_time_difference_string(
            (current_time - dog.sleep_time) - timedelta(hours=1)
        )

        await call.answer(
            f"{dog.name} –ø–æ—à–µ–ª —Å–ø–∞—Ç—å, –ø—Ä–æ—Å–Ω–µ—Ç—Å—è —á–µ—Ä–µ–∑ {time_difference}",
            show_alert=True,
        )

    if data[1] == "wakeup" and dog:
        await call.answer(f"{dog.name} –ø—Ä–æ—Å–Ω—É–ª—Å—è", show_alert=True)
        dog.sleep_time = utcnow()

    await database.users.async_update(**user.to_dict())
    if dog:
        await database.dogs.async_update(**dog.to_dict())
    await check_user_stats(user)


@router.callback_query(F.data.startswith("skip_quest"))
async def skip_quest_callback(call: CallbackQuery):
    if call.data.split(" ")[-1] != str(call.from_user.id):
        return

    if not isinstance(call.message, Message):
        return

    user = await database.users.async_get(id=call.from_user.id)

    if not user.new_quest_coin_quantity:
        user.new_quest_coin_quantity = 2

    if user.new_quest_coin_quantity > user.coin:
        await call.answer(
            (
                "–£ —Ç–µ–±—è –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–∞–±–ª–∞."
                f"–ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –Ω–æ–≤—ã–π –∫–≤–µ—Å—Ç –Ω–∞–¥–æ –∏–º–µ—Ç—å {user.new_quest_coin_quantity}"
            ),
            show_alert=True,
        )
        return

    generate_quest(user)
    user.coin -= user.new_quest_coin_quantity
    user.new_quest_coin_quantity += random.randint(10, 20)
    await database.users.async_update(**user.to_dict())

    await call.answer(
        "–¢—ã –ø–æ–ª—É—á–∏–ª –Ω–æ–≤—ã–π –∫–≤–µ—Å—Ç, –Ω–∞–ø–∏—à–∏ /quest —á—Ç–æ–±—ã –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å",
        show_alert=True,
    )


@router.callback_query(F.data.startswith("finish_quest"))
async def finish_quest_callback(call: CallbackQuery):
    if call.data.split(" ")[-1] != str(call.from_user.id):
        return

    if not isinstance(call.message, Message):
        return

    user = await database.users.async_get(id=call.from_user.id)

    try:
        quest = await database.quests.async_get(**{"owner": user._id})
    except NoResult:
        quest = generate_quest(user)

    item = get_or_add_user_item(user, quest.name)

    if item.quantity < quest.quantity:
        await call.answer("–ö—É–¥–∞–∞–∞, —Ç–µ–±–µ –Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç", show_alert=True)  # cspell:ignore –ö—É–¥–∞–∞–∞
        return

    item.quantity -= quest.quantity
    user.xp += quest.xp
    user.coin += quest.reward
    await database.users.async_update(**user.to_dict())
    await database.items.async_update(**item.to_dict())

    mess = (
        "–£—Ä–∞–∞, —Ç—ã –∑–∞–≤–µ—Ä—à–∏–ª –∫–≤–µ—Å—Ç\n"
        f"+ {int(quest.xp)} —Ö–ø\n"
        f"+ {quest.reward} –±–∞–±–ª–æ {get_item_emoji('–±–∞–±–ª–æ')}\n\n"
        "–¢—ã –≤—ã–ø–æ–ª–Ω–∏–ª –∫–≤–µ—Å—Ç –∑–∞ "
    )

    total_time = utcnow() - quest.start_time
    mess += get_time_difference_string(total_time)

    generate_quest(user)
    increment_achievement_progress(user, "–∫–≤–µ—Å—Ç–æ–º–∞–Ω")
    await call.message.delete()

    user_message = call.message.reply_to_message
    await call.message.answer_sticker(
        "CAACAgIAAxkBAAEpslFl2JwAAaZFMa3RM-3fKaHU7RYrOSQAAoIPAAJ73EFKS4aLwGmJ_Ok0BA",  # cspell:disable-line  # pylint: disable=line-too-long
    )
    if user_message:
        await user_message.reply(mess)
    else:
        await call.message.answer(mess)

    await check_user_stats(user, call.message.chat.id)


@router.callback_query(F.data.startswith("use"))
async def use_callback(call: CallbackQuery):
    if call.data.split(" ")[-1] != str(call.from_user.id):
        return

    user = await database.users.async_get(id=call.from_user.id)

    item = get_item(call.data.split(" ")[1])

    if not call.message.reply_to_message:
        return

    await use_item(call.message.reply_to_message, item.name)

    markup = InlineMarkup.use(user)

    items = get_available_items_for_use(user)

    if not items:
        mess = "–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ø—Ä–µ–¥–º–µ—Ç–æ–≤ –¥–ª—è —é–∑–∞"
        await call.message.edit_text(mess)

    await call.message.edit_reply_markup(reply_markup=markup)


@router.callback_query(F.data.startswith("item_info_main"))
async def item_info_main_callback(call: CallbackQuery):
    if call.data.split(" ")[-1] != str(call.from_user.id):
        return

    try:
        user = await database.users.async_get(id=call.from_user.id)
        action = call.data.split(" ")[1]
        pos = int(call.data.split(" ")[2])
        max_pos = len(list(batched(ITEMS, 6))) - 1

        if action == "next":
            pos += 1
        elif action == "back":
            pos -= 1
        elif action == "start":
            pos = 0
        elif action == "end":
            pos = max_pos

        if pos < 0:
            raise IndexError

        mess = f"<b>–ü—Ä–µ–¥–º–µ—Ç—ã</b>\n\n{pos + 1} / {max_pos + 1}"
        markup = InlineMarkup.items_pager(user=user, index=int(pos))

        await call.message.edit_text(mess, reply_markup=markup)
    except (IndexError, TelegramAPIError):
        await call.answer("–î–∞–ª—å—à–µ –Ω–∏—á–æ –Ω–µ—Ç—É", show_alert=True)


@router.callback_query(F.data.startswith("item_info"))
async def item_info_callback(call: CallbackQuery):
    if call.data.split(" ")[-1] != str(call.from_user.id):
        return

    item = get_item(call.data.split(" ")[1])
    pos = call.data.split(" ")[2]

    markup = quick_markup(
        {"–ù–∞–∑–∞–¥": {"callback_data": f"item_info_main None {pos} {call.from_user.id}"}}
    )

    craft = ""
    if item.craft:
        craft = ", ".join(
            [f"{get_item_emoji(name)} {name} {count}" for name, count in item.craft.items()]
        )

    mess = (
        f"<b>{item.emoji} {item.name}</b>\n\n"
        f"<b>–†–µ–¥–∫–æ—Å—Ç—å:</b> {item.rarity.value}\n\n"
        f"<b>–û–ø–∏—Å–∞–Ω–∏–µ:</b> <i>{item.desc}</i>\n\n"
        + (f"<b>–ö—Ä–∞—Ñ—Ç:</b> <i>{craft}</i>\n" if item.craft else "")
    )

    await call.message.edit_text(mess, reply_markup=markup)


@router.callback_query(F.data.startswith("trader"))
async def trader_callback(call: CallbackQuery):
    data = call.data.split(" ")
    if data[-1] != str(call.from_user.id):
        return

    if not isinstance(call.message, Message):
        return
    user = await database.users.async_get(id=call.from_user.id)

    if data[1] == "leave":
        await call.message.delete()
        await call.message.answer_sticker(
            "CAACAgEAAxkBAAEpxYVl3KqB7JnvbmYgXQqVAhUQYbnyXwACngIAAv9iMUeUcUiHcCrhSTQE",
        )
        await call.message.answer("–ü—Ñ... –Ω–µ —Ö–æ—á–µ—à—å –∫–∞–∫ —Ö–æ—á–µ—à—å")

    elif data[1] == "trade":
        item = get_item(data[2])
        quantity = int(data[3])
        price = int(data[4])
        user_item = get_or_add_user_item(user, item.name)

        if user.coin < price:
            await call.answer(f"–¢–µ–±–µ –Ω–µ—Ö–≤–∞—Ç–∞–µ—Ç {price - user.coin} –±–∞–±–ª–∞", show_alert=True)

            return

        user.coin -= price
        user_item.quantity += quantity
        await call.message.delete()
        await call.message.answer(f"–ö—É–ø–∏–ª {quantity} {item.name} {item.emoji} –∑–∞ {price}")


@router.callback_query(F.data.startswith("top"))
async def top_callback(call: CallbackQuery):
    data = call.data.split(" ")
    if data[-1] != str(call.from_user.id):
        return

    if not isinstance(call.message, Message):
        return

    markup = InlineMarkup.top(call.message)

    tops = {
        "coin": coin_top(),
        "level": level_top(),
        "dog_level": dog_level_top(),
        "karma": karma_top(),
    }

    try:
        await call.message.edit_text(tops[data[1]], reply_markup=markup)
    except TelegramAPIError:
        pass


@router.callback_query(F.data.startswith("chest"))
async def chest_callback(call: CallbackQuery):
    data = call.data.split(" ")

    if data[-1] != str(call.from_user.id):
        return

    if not isinstance(call.message, Message):
        return
    user = await database.users.async_get(id=call.from_user.id)

    if data[1] == "open":
        key = get_or_add_user_item(user, "–∫–ª—é—á")
        if key.quantity < 1:
            await call.answer("–£ —Ç–µ–±—è –Ω–µ—Ç –∫–ª—é—á–∞", show_alert=True)
            return
        key.quantity -= 1
        mess = "–û—Ç–∫—Ä—ã–ª —Å—É–Ω–¥—É–∫\n\n"
        items = []
        for _ in range(random.randint(2, 5)):
            rarity = random.choice(
                [
                    ItemRarity.COMMON,
                    ItemRarity.UNCOMMON,
                ]
            )
            quantity = get_item_count_for_rarity(rarity)
            item = random.choice(
                [item for item in ITEMS if item.rarity == rarity and item.name != "–±–∞–±–ª–æ"]
            )
            if item.name in items or quantity < 1:
                continue
            items.append(item.name)
            mess += f"+ {quantity} {item.name} {item.emoji}\n"
            user_item = get_or_add_user_item(user, item.name)
            user_item.quantity += quantity
            await database.items.async_update(**user_item.to_dict())
        increment_achievement_progress(user, "–∫–ª–∞–¥–æ–∏—Å–∫–∞—Ç–µ–ª—å")
        await call.message.delete()
        if call.message.reply_to_message:
            await call.message.reply(mess)
        else:
            await call.bot.send_message(user.id, mess)

    elif data[1] == "leave":
        await call.message.delete()
        if call.message.reply_to_message:
            await call.message.reply("*–£—à–µ–ª –æ—Ç —Å—É–Ω–¥—É–∫–∞*")


@router.callback_query(F.data.startswith("actions"))
async def actions_callback(call: CallbackQuery):
    data = call.data.split(" ")

    if data[-1] != str(call.from_user.id):
        return

    user = await database.users.async_get(id=call.from_user.id)

    if data[1] == "choice":
        markup = InlineMarkup.actions_choice(user)

        mess = "–ß–µ–º —Ö–æ—á–µ—à—å –∑–∞–Ω—è—Ç—å—Å—è?"

        await call.message.edit_text(mess, reply_markup=markup)
    elif data[1] == "back":
        markup = InlineMarkup.home_main(user)
        mess = "üè† –î–æ–º –º–∏–ª—ã–π –¥–æ–º"
        await call.message.edit_text(mess, reply_markup=markup)
    elif data[1] == "street":
        await street(call, user)
    elif data[1] == "work":
        await work(call, user)
    elif data[1] == "sleep":
        await sleep(call, user)
    elif data[1] == "game":
        await game(call, user)


@router.callback_query(F.data.startswith("open"))
async def open_callback(call: CallbackQuery):
    data = call.data.split(" ")

    if data[-1] != str(call.from_user.id):
        return

    user = await database.users.async_get(id=call.from_user.id)

    if data[1] == "home":
        mess = "üè† –î–æ–º –º–∏–ª—ã–π –¥–æ–º"
        markup = InlineMarkup.home_main(user)
    elif data[1] == "market-profile":
        mess = "–¢–≤–æ–π –ª–∞—Ä–µ–∫"
        markup = InlineMarkup.market_profile(user)
    elif data[1] == "bag":
        mess = "–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å"
        markup = InlineMarkup.bag(user)
    elif data[1] == "friends_list":
        mess = "–¢–≤–æ–∏ –¥—Ä—É–∑—å—è"
        markup = InlineMarkup.friends_list(user)
    elif data[1] == "profile":
        mess = Messages.profile(user)
        markup = InlineMarkup.open_friends_list(user)

    else:
        return
    await call.message.edit_text(mess, reply_markup=markup)


@router.callback_query(F.data.split(" ")[0] == "market")
async def market_callback(call: CallbackQuery, state: FSMContext):
    data = call.data.split(" ")

    if data[-1] != str(call.from_user.id):
        return

    user = await database.users.async_get(id=call.from_user.id)

    if data[1] == "add":
        user_market_items_len = len(database.market_items.get_all(owner=user._id))
        if user_market_items_len >= user.max_items_count_in_market:
            await call.answer("–¢—ã –ø—Ä–∏–≤–µ—Å–∏–ª –ª–∏–º–∏—Ç", show_alert=True)
            return
        from base.user_input.add_new_market_item import AddNewItemState

        user_items = sorted(
            await database.items.async_get_all(owner=user._id),
            key=lambda i: i.quantity,
            reverse=True,
        )

        buttons = []
        for item in user_items:
            if item.quantity <= 0 or get_item(item.name).type == ItemType.USABLE:
                continue

            buttons.append(
                InlineKeyboardButton(
                    text=f"{get_item_emoji(item.name)} {item.quantity}",
                    callback_data=f"sell {get_item(item.name).translit()} {user.id}",
                )
            )

        builder = InlineKeyboardBuilder()
        if len(buttons) == 0:
            await call.message.edit_text("–£ —Ç–µ–±—è –Ω–µ—Ç –ø—Ä–µ–¥–º–µ—Ç–æ–≤ –¥–ª—è –ø—Ä–æ–¥–∞–∂–∏")
            return

        builder.add(*buttons)
        builder.adjust(3)

        await state.set_state(AddNewItemState.name)

        await call.message.edit_text(
            "<b>–ü—Ä–æ–¥–∞–∂–∞ –ø—Ä–µ–¥–º–µ—Ç–∞</b>\n–í—ã–±–µ—Ä–∏ –ø—Ä–µ–¥–º–µ—Ç", reply_markup=builder.as_markup()
        )

    elif data[1] == "buy":
        try:
            market_item = database.market_items.get(_id=ObjectId(data[2]))
        except NoResult:
            await call.answer(
                "–≠—Ç–æ—Ç –ø—Ä–µ–¥–º–µ—Ç –ª–∏–±–æ —É–∂–µ –∫—É–ø–∏–ª–∏ –ª–∏–±–æ –≤–ª–∞–¥–µ–ª–µ—Ü —É–±—Ä–∞–ª —Å –ø—Ä–æ–¥–∞–∂–∏", show_alert=True
            )
            return

        item_owner = await database.users.async_get(_id=market_item.owner)

        if item_owner.id == user.id:
            await call.answer("–°–∞–º —É —Å–µ–±—è –±—É–¥–µ—à—å –ø–æ–∫—É–ø–∞—Ç—å?", show_alert=True)
            return

        if market_item.price > user.coin:
            await call.answer("–¢–µ–±–µ –Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç –±–∞–±–ª–∞", show_alert=True)
            return

        item = get_item(market_item.name)

        item_owner.coin += market_item.price
        user.coin -= market_item.price
        if item.type == ItemType.COUNTABLE:
            user_item = get_or_add_user_item(user, market_item.name)
            user_item.quantity += market_item.quantity
        else:
            user_item = add_user_usage_item(
                user,
                market_item.name,
                market_item.usage,  # type: ignore
            )
            user_item.quantity = market_item.quantity

        await database.items.async_update(**user_item.to_dict())
        await database.users.async_update(**user.to_dict())
        await database.users.async_update(**item_owner.to_dict())
        database.market_items.delete(**market_item.to_dict())

        increment_achievement_progress(user, "–±–æ–≥–∞—á", market_item.price)
        increment_achievement_progress(item_owner, "–ø—Ä–æ–¥–∞–≤–µ—Ü")

        usage = f" ({int(market_item.usage)}%)" if market_item.usage else ""
        emoji = get_item_emoji(market_item.name)
        mess = f"{get_user_tag(user)} –∫—É–ø–∏–ª {market_item.quantity} {emoji}{usage}"
        await safe(call.message.answer(mess))

        await safe(
            call.bot.send_message(
                item_owner.id,
                f"{get_user_tag(user)} –∫—É–ø–∏–ª —É —Ç–µ–±—è {market_item.quantity} {emoji}{usage}",
            )
        )

        mess = "<b>–†—ã–Ω–æ–∫</b>\n\n"
        market_items = database.market_items.get_all()
        markup = InlineMarkup.market_pager(user)
        mess += f"1 / {len(list(batched(market_items, 6)))}"
        await call.message.edit_text(
            mess,
            reply_markup=markup,
        )
    elif data[1] == "view-my-items":
        markup = InlineMarkup.market_view_my_items(user)

        mess = "<b>–¢–≤–æ–∏ —Ç–æ–≤–∞—Ä—ã</b>"
        await call.message.edit_text(
            mess,
            reply_markup=markup,
        )
    elif data[1] == "delete":
        market_item = database.market_items.get(_id=ObjectId(data[2]))
        user_item = get_or_add_user_item(user, market_item.name)
        user_item.quantity += market_item.quantity
        await database.items.async_update(**user_item.to_dict())
        database.market_items.delete(**market_item.to_dict())
        await call.answer(
            "–ø—Ä–µ–¥–º–µ—Ç —É–¥–∞–ª–µ–Ω —É—Å–ø–µ—à–Ω–æ",
            show_alert=True,
        )
        markup = InlineMarkup.market_view_my_items(user)

        await call.message.edit_reply_markup(
            reply_markup=markup,
        )

    else:
        try:
            action = call.data.split(" ")[1]
            pos = int(call.data.split(" ")[2])
            market_items = database.market_items.get_all()
            max_pos = len(list(batched(market_items, 6))) - 1

            if action == "next":
                pos += 1
            elif action == "back":
                pos -= 1
            elif action == "start":
                pos = 0
            elif action == "end":
                pos = max_pos

            if pos < 0 or pos > max_pos:
                raise IndexError

            mess = f"<b>–†—ã–Ω–æ–∫</b>\n\n{pos + 1} / {max_pos + 1}"
            markup = InlineMarkup.market_pager(user=user, index=pos)

            await call.message.edit_text(mess, reply_markup=markup)
        except IndexError:
            await call.answer("–î–∞–ª—å—à–µ –Ω–∏—á–æ –Ω–µ—Ç—É", show_alert=True)


@router.callback_query(F.data.startswith("market_item_open"))
async def market_item_open_callback(call: CallbackQuery):
    data = call.data.split(" ")

    if data[-1] != str(call.from_user.id):
        return

    user = await database.users.async_get(id=call.from_user.id)
    item_id = ObjectId(data[1])

    market_item = database.market_items.get(_id=item_id)

    item_owner = await database.users.async_get(_id=market_item.owner)
    emoji = get_item_emoji(market_item.name)
    mess = (
        f"<b>{emoji} {market_item.name} | {market_item.quantity} —à—Ç.</b>\n"
        f"–ü—Ä–æ–¥–∞–≤–µ—Ü: {get_user_tag(item_owner)}\n"
        f"–°—Ä–µ–¥–Ω–µ–π –ø—Ä–∞–π—Å: {get_middle_item_price(market_item.name)}/—à—Ç"
    )

    markup = InlineMarkup.market_item_open(user, market_item)
    await call.message.edit_text(mess, reply_markup=markup)


@router.callback_query(F.data.startswith("delate_state"), StateFilter("*"))
async def delate_state_callback(call: CallbackQuery, state: FSMContext):
    data = call.data.split(" ")

    if data[-1] != str(call.from_user.id):
        return

    if not await state.get_state():
        await call.answer("–ß—Ç–æ –æ—Ç–º–µ–Ω—è—Ç—å —Å–æ–±—Ä–∞–ª—Å—è?", show_alert=True)
        return
    await state.delete()
    if call.message.id:
        await call.message.delete()
    await call.answer("–û—Ç–º–µ–Ω–∏–ª")


@router.callback_query(F.data.startswith("levelup"))
async def levelup_callback(call: CallbackQuery):
    data = call.data.split(" ")

    if data[-1] != str(call.from_user.id):
        return

    user = await database.users.async_get(id=call.from_user.id)

    if data[1] == "luck":
        user.luck += 1
    elif data[1] == "market":
        user.max_items_count_in_market += 1

    user.karma += 2

    await database.users.async_update(**user.to_dict())
    await call.answer("–ü–æ–∑–¥—Ä–∞–≤–ª—è—é üéâüéâ", show_alert=True)
    await call.message.edit_reply_markup(reply_markup=None)


@router.callback_query(F.data.startswith("daily_gift"))
async def daily_gift_callback(call: CallbackQuery):
    data = call.data.split(" ")

    if data[-1] != str(call.from_user.id):
        return

    user = await database.users.async_get(id=call.from_user.id)

    if data[1] == "claim":
        if not await check_user_subscription(user):
            await call.answer(
                "–ß—Ç–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é –Ω—É–∂–Ω–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –Ω–æ–≤–æ—Å—Ç–Ω–æ–π –∫–∞–Ω–∞–ª",
                show_alert=True,
            )
            return
        now = utcnow()

        daily_gift = database.daily_gifts.get(owner=user._id)
        if daily_gift.is_claimed:
            time_difference = get_time_difference_string(daily_gift.next_claimable_at - now)
            await call.answer(
                f"–¢—ã —Å–µ–≥–æ–¥–Ω—è —É–∂–µ –ø–æ–ª—É—á–∏–ª –ø–æ–¥–∞—Ä–æ–∫. –ñ–¥–∏ {time_difference}",
                show_alert=True,
            )
            markup = InlineMarkup.daily_gift(user, daily_gift)
            await call.message.edit_reply_markup(reply_markup=markup)
            return

        if not daily_gift.last_claimed_at:
            daily_gift.last_claimed_at = now

        if daily_gift.last_claimed_at.date() == (now - timedelta(days=1)).date():
            daily_gift.streak += 1
        else:
            daily_gift.streak = 1

        daily_gift.last_claimed_at = now
        daily_gift.next_claimable_at = now + timedelta(days=1)
        daily_gift.is_claimed = True
        database.daily_gifts.update(**daily_gift.to_dict())

        mess = f"<b>{get_user_tag(user)} –ø–æ–ª—É—á–∏–ª –µ–∂–µ–¥–Ω–µ–≤–Ω—ã–π –ø–æ–¥–∞—Ä–æ–∫</b>\n\n"
        for item_name in daily_gift.items:
            item = get_item(item_name)
            quantity = get_item_count_for_rarity(item.rarity)
            try:
                user_item = get_or_add_user_item(user, item.name)
                user_item.quantity += quantity
                await database.items.async_update(**user_item.to_dict())
            except ItemIsCoin:
                user.coin += quantity
            mess += f"+{quantity} {item.name} {item.emoji}\n"

        markup = InlineMarkup.daily_gift(user, daily_gift)
        await call.message.answer(mess)
        await call.message.edit_reply_markup(reply_markup=markup)


@router.callback_query(F.data.startswith("transfer"))
async def transfer_callback(call: CallbackQuery):
    data = call.data.split(" ")

    if data[-1] != str(call.from_user.id):
        return

    user = await database.users.async_get(id=call.from_user.id)
    reply_user = await database.users.async_get(id=int(data[-2]))

    item = await database.items.async_get(_id=ObjectId(data[1]))

    if item.quantity <= 0:
        await call.answer("–£ —Ç–µ–±—è –Ω–µ—Ç —Ç–∞–∫–æ–≥–æ –ø—Ä–µ–¥–º–µ—Ç–∞")
        return

    item.owner = reply_user._id

    await database.items.async_update(**item.to_dict())
    mess = (
        f"{user.name} –ø–æ–¥–∞—Ä–∏–ª {reply_user.name}\n"
        "----------------\n"
        f"{get_item_emoji(item.name)} {item.name} ({int(item.usage)}%)"  # type: ignore
    )

    await database.users.async_update(**user.to_dict())
    await database.users.async_update(**reply_user.to_dict())

    await call.message.answer(mess)


@router.callback_query(F.data.startswith("achievements"))
async def achievements_callback(call: CallbackQuery):
    data = call.data.split(" ")

    if data[-1] != str(call.from_user.id):
        return

    user = await database.users.async_get(id=call.from_user.id)

    if data[1] == "view":
        ach = get_achievement(data[2])
        mess = f"<b>{ach.emoji} {ach.name}</b>\n\n"
        mess += f"<i>{ach.desc}</i>\n\n"
        mess += f"{achievement_progress(user, ach.name)}"

        markup = quick_markup({"–ù–∞–∑–∞–¥": {"callback_data": f"achievements main {user.id}"}})

        await call.message.edit_text(mess, reply_markup=markup)
    elif data[1] == "main":
        mess = "–î–æ—Å—Ç–∏–∂–µ–Ω–∏—è"

        markup = InlineMarkup.achievements(user)

        await call.message.edit_text(mess, reply_markup=markup)

    elif data[1] == "filter":
        filter = data[2]
        markup = InlineMarkup.achievements_view(user, filter)  # type: ignore

        await call.message.edit_reply_markup(reply_markup=markup)


@router.callback_query(F.data.startswith("accept_rules"))
async def accept_rules_callback(call: CallbackQuery):
    data = call.data.split(" ")

    if data[-1] != str(call.from_user.id):
        return

    user = await database.users.async_get(id=call.from_user.id)
    user.accepted_rules = True
    user.karma += 3
    await database.users.async_update(**user.to_dict())

    await call.answer(
        "–¢–µ–ø–µ—Ä—å –º–æ–∂–µ—à—å —Å–ø–æ–∫–æ–π–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞–ª—Å—è –±–æ—Ç–æ–º",
        show_alert=True,
    )

    await call.message.delete()  # type: ignore


@router.callback_query(F.data.startswith("event_shop"))
async def event_shop_callback(call: CallbackQuery):
    data = call.data.split(" ")

    if data[-1] != str(call.from_user.id):
        return

    if data[1] != "buy":
        return

    user = await database.users.async_get(id=call.from_user.id)

    candy = get_or_add_user_item(user, "–∫–æ–Ω—Ñ–µ—Ç–∞")

    item = get_item(data[2])
    quantity = int(data[3])

    if candy.quantity < quantity:
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫–æ–Ω—Ñ–µ—Ç", show_alert=True)
        return

    user_item = get_or_add_user_item(user, item.name)
    user_item.quantity += 1
    candy.quantity -= quantity

    await database.items.async_update(**user_item.to_dict())
    await database.items.async_update(**candy.to_dict())

    mess = "<b>–ò–≤–µ–Ω—Ç–æ–≤—ã–π –º–∞–≥–∞–∑–∏–Ω</b>\n\n"
    mess += f"–£ —Ç–µ–±—è {candy.quantity} {get_item_emoji(candy.name)}"

    markup = InlineMarkup.event_shop(user)

    await call.message.edit_text(mess, reply_markup=markup)

    await call.answer(
        f"–¢—ã –∫—É–ø–∏–ª 1 {item.emoji} –∑–∞ {quantity} {get_item_emoji(candy.name)}",
        show_alert=True,
    )


@router.callback_query(F.data.startswith("friend"))
async def friend_callback(call: CallbackQuery):
    data = call.data.split(" ")

    if data[-1] != str(call.from_user.id):
        return

    user = await database.users.async_get(id=call.from_user.id)

    if data[1] == "view":
        friend = await database.users.async_get(id=int(data[2]))
        mess = Messages.profile(friend)
        markup = quick_markup({"–ù–∞–∑–∞–¥": {"callback_data": f"friend main-menu {user.id}"}})
        await call.message.edit_text(mess, reply_markup=markup)
    elif data[1] == "main-menu":
        markup = InlineMarkup.friends_list(user)
        mess = "–¢–≤–æ–∏ –¥—Ä—É–∑—å—è"
        await call.message.edit_text(mess, reply_markup=markup)
